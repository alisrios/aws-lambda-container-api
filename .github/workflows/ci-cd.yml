name: CI/CD Pipeline

on:
  workflow_dispatch:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: lambda-container-api-dev
  TERRAFORM_VERSION: 1.6.0

# Global permissions for OIDC
permissions:
  id-token: write   # Required for OIDC
  contents: read    # Required for checkout
  security-events: write  # Required for security scanning
  pull-requests: write    # Required for PR comments

jobs:
  test:
    name: Test and Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements-dev.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        # Install with dependency resolution backtracking
        pip install --use-pep517 -r requirements-dev.txt
        
    - name: Code formatting check (Black)
      run: |
        black --check --diff src/ tests/
        
    - name: Import sorting check (isort)
      run: |
        isort --check-only --diff src/ tests/
        
    - name: Lint with flake8
      run: |
        # Stop the build if there are Python syntax errors or undefined names
        flake8 src/ tests/ --count --select=E9,F63,F7,F82 --show-source --statistics
        # Exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 src/ tests/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Run unit tests with coverage
      run: |
        pytest tests/unit/ --cov=src --cov-report=xml --cov-report=term-missing
        
    - name: Run integration tests
      run: |
        pytest tests/integration/ -v
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Cache pip dependencies for security scan
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-security-pip-${{ hashFiles('requirements-dev.txt', 'src/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-security-pip-
          ${{ runner.os }}-pip-
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
        pip install safety bandit semgrep
        
    - name: Run safety check for vulnerabilities
      run: |
        echo "Running safety check for known vulnerabilities..."
        safety check --json --output safety-report.json || true
        safety check --short-report || echo "Safety check completed with warnings"
        
    - name: Run bandit security linter
      run: |
        echo "Running bandit security analysis..."
        bandit -r src/ -f json -o bandit-report.json || true
        bandit -r src/ -f txt || echo "Bandit analysis completed with warnings"
        
    - name: Run semgrep security analysis
      run: |
        echo "Running semgrep security analysis..."
        semgrep --config=auto src/ --json --output=semgrep-report.json || true
        semgrep --config=auto src/ --text || echo "Semgrep analysis completed with warnings"
        
    - name: Upload security scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          safety-report.json
          bandit-report.json
          semgrep-report.json
        retention-days: 30
        
    - name: Security scan summary
      if: always()
      run: |
        echo "## 🔒 Security Scan Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Safety (Dependency Vulnerabilities)" >> $GITHUB_STEP_SUMMARY
        if [ -f safety-report.json ]; then
          echo "✅ Safety scan completed - check artifacts for details" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Safety scan failed" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Bandit (Code Security Issues)" >> $GITHUB_STEP_SUMMARY
        if [ -f bandit-report.json ]; then
          echo "✅ Bandit scan completed - check artifacts for details" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Bandit scan failed" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Semgrep (Advanced Security Analysis)" >> $GITHUB_STEP_SUMMARY
        if [ -f semgrep-report.json ]; then
          echo "✅ Semgrep scan completed - check artifacts for details" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Semgrep scan failed" >> $GITHUB_STEP_SUMMARY
        fi

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    outputs:
      image-uri: ${{ steps.build-vars.outputs.full-image-latest }}
      image-tag: ${{ steps.build-vars.outputs.commit-hash }}
      ecr-repository: ${{ steps.build-vars.outputs.ecr-repository-name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-BuildAndPush-${{ github.run_id }}
        
    - name: Set build variables
      id: build-vars
      run: |
        # Set project variables
        PROJECT_NAME="lambda-container-api"
        ENVIRONMENT="dev"
        
        # Get commit hash (7 digits)
        COMMIT_HASH=$(echo ${{ github.sha }} | cut -c1-7)
        
        # Build repository name
        ECR_REPOSITORY_NAME="${PROJECT_NAME}-${ENVIRONMENT}"
        
        # Get AWS Account ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        
        # Build full image names
        FULL_IMAGE_LATEST="${ECR_URI}/${ECR_REPOSITORY_NAME}:latest"
        FULL_IMAGE_COMMIT="${ECR_URI}/${ECR_REPOSITORY_NAME}:${COMMIT_HASH}"
        
        # Set outputs
        echo "project-name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
        echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
        echo "commit-hash=${COMMIT_HASH}" >> $GITHUB_OUTPUT
        echo "ecr-repository-name=${ECR_REPOSITORY_NAME}" >> $GITHUB_OUTPUT
        echo "account-id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT
        echo "ecr-uri=${ECR_URI}" >> $GITHUB_OUTPUT
        echo "full-image-latest=${FULL_IMAGE_LATEST}" >> $GITHUB_OUTPUT
        echo "full-image-commit=${FULL_IMAGE_COMMIT}" >> $GITHUB_OUTPUT
        
        # Print configuration
        echo "📋 Build Configuration:"
        echo "   - Project: ${PROJECT_NAME}"
        echo "   - Environment: ${ENVIRONMENT}"
        echo "   - Repository: ${ECR_REPOSITORY_NAME}"
        echo "   - Commit Hash: ${COMMIT_HASH}"
        echo "   - Latest Image: ${FULL_IMAGE_LATEST}"
        echo "   - Commit Image: ${FULL_IMAGE_COMMIT}"
        
    - name: Create ECR repository if not exists
      run: |
        echo "🔍 Checking if ECR repository exists..."
        if aws ecr describe-repositories --repository-names "${{ steps.build-vars.outputs.ecr-repository-name }}" --region "${{ env.AWS_REGION }}" >/dev/null 2>&1; then
          echo "✅ ECR repository already exists: ${{ steps.build-vars.outputs.ecr-repository-name }}"
        else
          echo "📝 Creating ECR repository: ${{ steps.build-vars.outputs.ecr-repository-name }}"
          aws ecr create-repository \
            --repository-name "${{ steps.build-vars.outputs.ecr-repository-name }}" \
            --region "${{ env.AWS_REGION }}" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
          echo "✅ ECR repository created successfully!"
        fi
        
    - name: Login to Amazon ECR
      id: login-ecr
      run: |
        echo "🔐 Logging into ECR..."
        aws ecr get-login-password --region "${{ env.AWS_REGION }}" | docker login --username AWS --password-stdin "${{ steps.build-vars.outputs.ecr-uri }}"
        echo "✅ ECR login successful"
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:v0.12.0
          network=host
          
    - name: Clean up old local images
      run: |
        echo "🧹 Cleaning up old local images..."
        docker rmi "${{ steps.build-vars.outputs.ecr-repository-name }}:latest" 2>/dev/null || true
        docker rmi "${{ steps.build-vars.outputs.ecr-repository-name }}:${{ steps.build-vars.outputs.commit-hash }}" 2>/dev/null || true
        docker rmi "${{ steps.build-vars.outputs.full-image-latest }}" 2>/dev/null || true
        docker rmi "${{ steps.build-vars.outputs.full-image-commit }}" 2>/dev/null || true
        echo "✅ Cleanup completed"
        
    - name: Build Docker image for Lambda
      run: |
        echo "🏗️ Building Docker image for AWS Lambda (linux/amd64)..."
        docker buildx build \
          --platform linux/amd64 \
          --load \
          -t "${{ steps.build-vars.outputs.ecr-repository-name }}:latest" \
          -t "${{ steps.build-vars.outputs.ecr-repository-name }}:${{ steps.build-vars.outputs.commit-hash }}" \
          .
        echo "✅ Docker build completed"
        
    - name: Tag images for ECR
      run: |
        echo "🏷️ Tagging images for ECR..."
        docker tag "${{ steps.build-vars.outputs.ecr-repository-name }}:latest" "${{ steps.build-vars.outputs.full-image-latest }}"
        docker tag "${{ steps.build-vars.outputs.ecr-repository-name }}:${{ steps.build-vars.outputs.commit-hash }}" "${{ steps.build-vars.outputs.full-image-commit }}"
        echo "✅ Images tagged successfully"
        
    - name: Test Docker image
      run: |
        echo "🧪 Testing Docker image..."
        docker run --rm --platform linux/amd64 --entrypoint="" "${{ steps.build-vars.outputs.ecr-repository-name }}:latest" python -c "
        import lambda_function
        import app
        print('✅ All modules imported successfully')
        print('✅ Image OK')
        " || {
          echo "❌ Error: Image failed basic test"
          exit 1
        }
        echo "✅ Image test passed"
        
    - name: Verify image compatibility
      run: |
        echo "🔍 Verifying image compatibility with Lambda..."
        
        # Check architecture
        ARCH=$(docker inspect "${{ steps.build-vars.outputs.full-image-latest }}" --format='{{.Architecture}}')
        if [ "$ARCH" != "amd64" ]; then
          echo "❌ Error: Image is not amd64 architecture: $ARCH"
          exit 1
        fi
        echo "✅ Architecture check passed: $ARCH"
        
        # Check if images are tagged correctly
        if ! docker images | grep -q "${{ steps.build-vars.outputs.ecr-repository-name }}"; then
          echo "❌ Error: Images not tagged correctly"
          exit 1
        fi
        echo "✅ Image tags verified"
        
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@0.28.0
      with:
        image-ref: ${{ steps.build-vars.outputs.ecr-repository-name }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'
        
    - name: Run Trivy vulnerability scanner (table format)
      uses: aquasecurity/trivy-action@0.28.0
      with:
        image-ref: ${{ steps.build-vars.outputs.ecr-repository-name }}:latest
        format: 'table'
        severity: 'CRITICAL,HIGH'
        
    - name: Push images to ECR
      id: push-image
      run: |
        echo "📤 Pushing images to ECR..."
        echo "   - Pushing latest tag..."
        docker push "${{ steps.build-vars.outputs.full-image-latest }}"
        echo "   - Pushing commit tag (${{ steps.build-vars.outputs.commit-hash }})..."
        docker push "${{ steps.build-vars.outputs.full-image-commit }}"
        
        # Get image digest
        DIGEST=$(docker inspect "${{ steps.build-vars.outputs.full-image-latest }}" --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
        echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
        
        echo "✅ Images pushed successfully!"
        
    - name: Verify ECR push
      run: |
        echo "✅ Verifying images in ECR..."
        aws ecr describe-images \
          --repository-name "${{ steps.build-vars.outputs.ecr-repository-name }}" \
          --region "${{ env.AWS_REGION }}" \
          --image-ids imageTag="latest" >/dev/null 2>&1 || {
          echo "❌ Error: Failed to verify image in ECR"
          exit 1
        }
        echo "✅ ECR verification successful"
        
    - name: Update Lambda function if exists
      run: |
        echo "🔍 Checking if Lambda function exists..."
        LAMBDA_FUNCTION_NAME="${{ steps.build-vars.outputs.project-name }}-${{ steps.build-vars.outputs.environment }}"
        if aws lambda get-function --function-name "${LAMBDA_FUNCTION_NAME}" --region "${{ env.AWS_REGION }}" >/dev/null 2>&1; then
          echo "🔄 Updating Lambda function code..."
          aws lambda update-function-code \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --image-uri "${{ steps.build-vars.outputs.full-image-latest }}" \
            --region "${{ env.AWS_REGION }}"
          echo "✅ Lambda function updated!"
        else
          echo "ℹ️ Lambda function doesn't exist yet - will be created by Terraform"
        fi
        
    - name: Generate SBOM
      uses: anchore/sbom-action@v0.17.2
      with:
        image: ${{ steps.build-vars.outputs.full-image-latest }}
        format: spdx-json
        output-file: sbom.spdx.json
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.spdx.json
        retention-days: 30
        
    - name: Build summary
      run: |
        echo "## 📦 Docker Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Configuration:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Project:** ${{ steps.build-vars.outputs.project-name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** ${{ steps.build-vars.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Repository:** ${{ steps.build-vars.outputs.ecr-repository-name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit Hash:** ${{ steps.build-vars.outputs.commit-hash }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Images Created:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Latest:** ${{ steps.build-vars.outputs.full-image-latest }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ steps.build-vars.outputs.full-image-commit }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Get image size
        IMAGE_SIZE=$(docker images "${{ steps.build-vars.outputs.ecr-repository-name }}:latest" --format "table {{.Size}}" | tail -n 1)
        echo "**Image Size:** $IMAGE_SIZE" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "✅ **Status:** Build and push completed successfully!" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    outputs:
      api-url: ${{ steps.terraform-output.outputs.api_url }}
      lambda-function-name: ${{ steps.terraform-output.outputs.lambda_function_name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Deploy-${{ github.run_id }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Debug Information
      run: |
        echo "🔍 Informações de Debug:"
        echo "   - Working Directory: $(pwd)"
        echo "   - AWS Region: ${{ env.AWS_REGION }}"
        echo "   - Image URI: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "   - Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "   - ECR Repository: ${{ needs.build-and-push.outputs.ecr-repository }}"
        echo "   - GitHub Repository: ${{ github.repository }}"
        echo "   - GitHub SHA: ${{ github.sha }}"
        echo ""
        echo "📁 Estrutura do diretório:"
        find . -name "*.tf" -o -name "*.tfvars" | head -20
        
    - name: Check Terraform files
      run: |
        echo "🔍 Verificando arquivos Terraform..."
        ls -la
        echo ""
        echo "📋 Conteúdo dos arquivos principais:"
        if [ -f "main.tf" ]; then
          echo "✅ main.tf encontrado"
        else
          echo "❌ main.tf não encontrado"
          exit 1
        fi
        
        if [ -f "backend.tf" ]; then
          echo "✅ backend.tf encontrado"
        else
          echo "❌ backend.tf não encontrado"
          exit 1
        fi
        
        if [ -f "variables.tf" ]; then
          echo "✅ variables.tf encontrado"
        else
          echo "⚠️ variables.tf não encontrado - criando arquivo básico"
          cat > variables.tf << 'EOF'
        variable "project_name" {
          description = "Nome do projeto"
          type        = string
          default     = "lambda-container-api"
        }
        
        variable "environment" {
          description = "Ambiente (dev, staging, prod)"
          type        = string
          default     = "dev"
        }
        
        variable "aws_region" {
          description = "Região AWS"
          type        = string
          default     = "us-east-1"
        }
        
        variable "ecr_image_tag" {
          description = "Tag da imagem ECR"
          type        = string
          default     = "latest"
        }
        
        variable "ecr_repository_name" {
          description = "Nome do repositório ECR"
          type        = string
          default     = "lambda-container-api-dev"
        }
        EOF
        fi
      working-directory: terraform
        
    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check -recursive
      working-directory: terraform
      continue-on-error: true
      
    - name: Check and Fix Terraform Configuration
      run: |
        echo "🔍 Verificando configuração do Terraform..."
        
        # Verificar se backend.tf existe
        if [ -f "backend.tf" ]; then
          echo "📋 Conteúdo do backend.tf:"
          cat backend.tf
        else
          echo "❌ Arquivo backend.tf não encontrado!"
          exit 1
        fi
        
        echo ""
        echo "🔧 Verificando sintaxe dos arquivos Terraform..."
        
        # Verificar se há problemas de sintaxe
        for file in *.tf; do
          if [ -f "$file" ]; then
            echo "Verificando $file..."
            # Verificar se o arquivo tem sintaxe válida
            if ! terraform fmt -check "$file" >/dev/null 2>&1; then
              echo "⚠️ Formatando $file..."
              terraform fmt "$file"
            fi
          fi
        done
        
        echo "✅ Verificação de sintaxe concluída"
        
        # Verificar se há referências problemáticas
        echo ""
        echo "🔍 Verificando referências de variáveis..."
        if grep -r "checkable" . 2>/dev/null; then
          echo "⚠️ Encontradas referências 'checkable' problemáticas"
        fi
        
        # Verificar versões no versions.tf
        if [ -f "versions.tf" ]; then
          echo "📋 Conteúdo do versions.tf:"
          cat versions.tf
        fi
        
        # Se o backend.tf tem problemas, criar um limpo
        if grep -q "use_lockfile" backend.tf 2>/dev/null; then
          echo "⚠️ Encontrado parâmetro 'use_lockfile' inválido no backend.tf"
          echo "🔧 Criando backend.tf limpo..."
          cat > backend.tf << 'EOF'
        # Backend configuration for Terraform state
        # This stores the Terraform state in S3 with versioning for state protection
        
        terraform {
          backend "s3" {
            bucket  = "bucket-state-locking"
            key     = "lambda-container-api/terraform.tfstate"
            region  = "us-east-1"
            encrypt = true
          }
        }
        EOF
          echo "✅ backend.tf corrigido"
        fi
      working-directory: terraform
        
    - name: Terraform Init
      id: init
      run: |
        echo "🔄 Inicializando Terraform..."
        
        # Limpar cache do Terraform se existir
        rm -rf .terraform .terraform.lock.hcl
        
        # Verificar versão do Terraform
        terraform version
        
        # Tentar inicializar com diferentes estratégias
        echo "Tentativa 1: Init com reconfigure..."
        if terraform init -reconfigure; then
          echo "✅ Terraform inicializado com sucesso!"
        else
          echo "⚠️ Falha na primeira tentativa"
          echo "Tentativa 2: Init com upgrade..."
          if terraform init -upgrade; then
            echo "✅ Terraform inicializado com upgrade!"
          else
            echo "⚠️ Falha na segunda tentativa"
            echo "Tentativa 3: Init básico..."
            if terraform init; then
              echo "✅ Terraform inicializado com init básico!"
            else
              echo "❌ Todas as tentativas de inicialização falharam"
              echo "📋 Informações de debug:"
              ls -la
              echo ""
              echo "📋 Conteúdo do backend.tf:"
              cat backend.tf
              echo ""
              echo "📋 Logs detalhados:"
              terraform init -reconfigure 2>&1 || true
              exit 1
            fi
          fi
        fi
      working-directory: terraform
      
    - name: Terraform Validate
      id: validate
      run: |
        echo "🔍 Validando configuração do Terraform..."
        if terraform validate -no-color; then
          echo "✅ Configuração Terraform válida!"
        else
          echo "❌ Erro na validação do Terraform"
          echo "📋 Tentando identificar o problema..."
          
          # Verificar se há problemas específicos com variáveis
          echo "Verificando arquivos de variáveis..."
          if [ -f "variables.tf" ]; then
            echo "📋 Conteúdo do variables.tf:"
            head -20 variables.tf
          fi
          
          # Verificar se há problemas com versões
          echo "📋 Verificando versões do provider..."
          terraform version
          terraform providers
          
          exit 1
        fi
      working-directory: terraform
      
    - name: Terraform Plan
      id: plan
      run: |
        # Criar arquivo terraform.tfvars com as variáveis necessárias
        cat > terraform.tfvars << EOF
        project_name = "lambda-container-api"
        environment = "dev"
        aws_region = "${{ env.AWS_REGION }}"
        ecr_image_tag = "${{ needs.build-and-push.outputs.image-tag }}"
        ecr_repository_name = "${{ needs.build-and-push.outputs.ecr-repository }}"
        EOF
        
        # Executar terraform plan
        terraform plan -no-color -input=false -out=tfplan
      working-directory: terraform
      continue-on-error: true
      
    - name: Comment PR with Terraform Plan
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const output = `#### Terraform Format and Style 🖌\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
          #### Terraform Validation 🤖\`${{ steps.validate.outcome }}\`
          #### Terraform Plan 📖\`${{ steps.plan.outcome }}\`
          
          <details><summary>Show Plan</summary>
          
          \`\`\`terraform
          ${{ steps.plan.outputs.stdout }}
          \`\`\`
          
          </details>
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })
          
    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
      id: apply
      run: |
        echo "🚀 Aplicando mudanças do Terraform..."
        if terraform apply -auto-approve tfplan; then
          echo "✅ Terraform apply executado com sucesso!"
        else
          echo "❌ Erro no terraform apply"
          echo "📋 Verificando estado atual..."
          terraform state list || echo "Nenhum estado encontrado"
          exit 1
        fi
      working-directory: terraform
      
    - name: Get Terraform Outputs
      id: terraform-output
      if: steps.apply.outcome == 'success'
      run: |
        echo "🔍 Verificando outputs do Terraform..."
        terraform output
        echo ""
        
        # Verificar se os outputs existem antes de tentar obtê-los
        if terraform output api_gateway_url >/dev/null 2>&1; then
          API_URL=$(terraform output -raw api_gateway_url)
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "✅ API Gateway URL: ${API_URL}"
        else
          echo "⚠️ Output api_gateway_url não encontrado"
          echo "api_url=not-available" >> $GITHUB_OUTPUT
        fi
        
        if terraform output lambda_function_name >/dev/null 2>&1; then
          LAMBDA_NAME=$(terraform output -raw lambda_function_name)
          echo "lambda_function_name=${LAMBDA_NAME}" >> $GITHUB_OUTPUT
          echo "✅ Lambda Function Name: ${LAMBDA_NAME}"
        else
          echo "⚠️ Output lambda_function_name não encontrado"
          echo "lambda_function_name=not-available" >> $GITHUB_OUTPUT
        fi
      working-directory: terraform
      
    - name: Handle Terraform Errors
      if: steps.plan.outcome == 'failure' || steps.apply.outcome == 'failure'
      run: |
        echo "Terraform deployment failed. Check the logs above for details."
        echo "Plan outcome: ${{ steps.plan.outcome }}"
        echo "Apply outcome: ${{ steps.apply.outcome }}"
        exit 1

  e2e-test:
    name: End-to-End Testing
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Cache pip dependencies for E2E tests
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-e2e-pip-${{ hashFiles('requirements-dev.txt') }}
        restore-keys: |
          ${{ runner.os }}-e2e-pip-
          ${{ runner.os }}-pip-
        
    - name: Install test dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytest statistics
        
    - name: Wait for API to be ready
      run: |
        echo "Waiting for API to be ready..."
        sleep 30
        
    - name: Test Hello endpoint
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Testing Hello endpoint: ${API_URL}/hello"
        
        response=$(curl -s -w "%{http_code}" -o response.json "${API_URL}/hello")
        http_code=${response: -3}
        
        if [ "$http_code" != "200" ]; then
          echo "Hello endpoint failed with HTTP code: $http_code"
          cat response.json
          exit 1
        fi
        
        echo "Hello endpoint test passed!"
        cat response.json
        
    - name: Test Echo endpoint
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Testing Echo endpoint: ${API_URL}/echo?msg=test"
        
        response=$(curl -s -w "%{http_code}" -o response.json "${API_URL}/echo?msg=test")
        http_code=${response: -3}
        
        if [ "$http_code" != "200" ]; then
          echo "Echo endpoint failed with HTTP code: $http_code"
          cat response.json
          exit 1
        fi
        
        echo "Echo endpoint test passed!"
        cat response.json
        
    - name: Test Echo endpoint without parameter
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Testing Echo endpoint without parameter: ${API_URL}/echo"
        
        response=$(curl -s -w "%{http_code}" -o response.json "${API_URL}/echo")
        http_code=${response: -3}
        
        if [ "$http_code" != "400" ]; then
          echo "Echo endpoint without parameter should return 400, got: $http_code"
          cat response.json
          exit 1
        fi
        
        echo "Echo endpoint error handling test passed!"
        cat response.json
        
    - name: Test Health endpoint
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Testing Health endpoint: ${API_URL}/health"
        
        response=$(curl -s -w "%{http_code}" -o response.json "${API_URL}/health")
        http_code=${response: -3}
        
        if [ "$http_code" != "200" ]; then
          echo "Health endpoint failed with HTTP code: $http_code"
          cat response.json
          exit 1
        fi
        
        # Verify health response structure
        status=$(cat response.json | python3 -c "import sys, json; print(json.load(sys.stdin)['status'])")
        if [ "$status" != "healthy" ]; then
          echo "Health endpoint returned unhealthy status: $status"
          cat response.json
          exit 1
        fi
        
        echo "Health endpoint test passed!"
        cat response.json
        
    - name: Test Monitoring Headers
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Testing monitoring headers on all endpoints"
        
        endpoints=("/hello" "/echo?msg=monitoring_test" "/health")
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing endpoint: ${endpoint}"
          
          # Test with custom request ID
          custom_id="ci-cd-test-$(date +%s)"
          response=$(curl -s -w "%{http_code}" -H "X-Request-ID: ${custom_id}" -D headers.txt "${API_URL}${endpoint}")
          http_code=${response: -3}
          
          if [ "$http_code" != "200" ]; then
            echo "Endpoint ${endpoint} failed with HTTP code: $http_code"
            exit 1
          fi
          
          # Check for monitoring headers
          if ! grep -q "X-Request-ID: ${custom_id}" headers.txt; then
            echo "Missing or incorrect X-Request-ID header for ${endpoint}"
            cat headers.txt
            exit 1
          fi
          
          if ! grep -q "X-Response-Time:" headers.txt; then
            echo "Missing X-Response-Time header for ${endpoint}"
            cat headers.txt
            exit 1
          fi
          
          echo "Monitoring headers test passed for ${endpoint}"
        done
        
    - name: Run E2E Monitoring Tests
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        export DEPLOYED_API_URL="${API_URL}"
        
        # Run specific monitoring E2E tests
        pytest tests/e2e/test_monitoring_e2e.py -v --tb=short
        
    - name: Run Performance Validation
      run: |
        API_URL="${{ needs.deploy.outputs.api-url }}"
        echo "Running performance validation against: ${API_URL}"
        
        # Run performance validation with moderate load for CI/CD
        python scripts/validate_performance.py \
          --api-url "${API_URL}" \
          --requests 50 \
          --concurrency 5 \
          --output performance-results.json
        
    - name: Upload Performance Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: performance-results
        path: performance-results.json
        retention-days: 30
        
    - name: Performance Summary
      if: always()
      run: |
        if [ -f performance-results.json ]; then
          echo "## 🚀 Performance Validation Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Extract key metrics from results
          SUCCESS=$(python3 -c "import json; data=json.load(open('performance-results.json')); print('✅ PASS' if data['overall_success'] else '❌ FAIL')")
          echo "**Overall Result:** $SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**Endpoint Performance:**" >> $GITHUB_STEP_SUMMARY
          python3 -c "import json; data=json.load(open('performance-results.json')); [print(f'- **{results[\"analysis\"][\"endpoint\"]}**: {results[\"analysis\"][\"success_rate\"]:.1f}% success, {results[\"analysis\"][\"response_times\"][\"avg_ms\"]:.1f}ms avg') for endpoint, results in data['endpoint_results'].items()]" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📊 Detailed results available in artifacts" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Performance validation failed to generate results" >> $GITHUB_STEP_SUMMARY
        fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy, e2e-test]
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
    - name: Deployment Success Notification
      if: needs.deploy.result == 'success' && needs.e2e-test.result == 'success'
      run: |
        echo "🎉 Deployment Successful!"
        echo "API URL: ${{ needs.deploy.outputs.api-url }}"
        echo "Lambda Function: ${{ needs.deploy.outputs.lambda-function-name }}"
        echo "Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        
        # Create deployment summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # 🚀 Deployment Summary
        
        ## ✅ Deployment Successful
        
        - **API URL**: ${{ needs.deploy.outputs.api-url }}
        - **Lambda Function**: ${{ needs.deploy.outputs.lambda-function-name }}
        - **Environment**: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        
        ## 🧪 Test Results
        - Unit Tests: ✅ Passed
        - Integration Tests: ✅ Passed
        - Security Scan: ✅ Passed
        - End-to-End Tests: ✅ Passed
        
        ## 📋 Next Steps
        - Test the API endpoints using the URL above
        - Monitor CloudWatch logs for any issues
        - Check the Lambda function metrics in AWS Console
        EOF
        
    - name: Deployment Failure Notification
      if: needs.deploy.result == 'failure' || needs.e2e-test.result == 'failure'
      run: |
        echo "❌ Deployment Failed!"
        echo "Deploy Status: ${{ needs.deploy.result }}"
        echo "E2E Test Status: ${{ needs.e2e-test.result }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        
        # Create failure summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # 💥 Deployment Failed
        
        ## ❌ Deployment Status
        - **Deploy Job**: ${{ needs.deploy.result }}
        - **E2E Test Job**: ${{ needs.e2e-test.result }}
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        
        ## 🔍 Troubleshooting
        1. Check the job logs above for detailed error messages
        2. Verify AWS credentials and permissions
        3. Check Terraform state and resource conflicts
        4. Validate Docker image build and ECR push
        
        ## 📞 Support
        - Review the workflow logs for specific error details
        - Check AWS CloudWatch logs for runtime errors
        - Verify all required secrets are configured
        EOF
        
        exit 1
